两个问题
-----
1. 假设现在是 20018-12-03 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 20018-12-03 12:00:01.000 的时候，这个线程会不会被唤醒？  

2. 某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？  

​        对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。aaa
​        Thread.Sleep(0)的作用，就是“让出cpu，会触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。

sleep的底层实现
---
sleep()：进程、线程或任务(Linux中不区分进程与线程，都称为task)可以sleep，这会导致它们暂停执行一段时间，直到等待的时间结束才恢复执行或在这段时间内被中断。
sleep()在OS中的实现的大概流程：

挂起进程（或线程）并修改其运行状态
用sleep()提供的参数来设置一个定时器。
当时间结束，定时器会触发，内核收到中断后修改进程（或线程）的运行状态。例如线程会被标志为就绪而进入就绪队列等待调度。
可变定时器(variable timer)一般在硬件层面是通过一个固定的时钟和计数器来实现的，每经过一个时钟周期将计数器递减，当计数器的值为0时产生中断。内核注册一个定时器后可以在一段时间后收到中断。
````c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
///时钟编程 alarm()
void wakeUp()
{
    printf("please wakeup!!\n");
}
int main(void)
{
    printf("you have 4 s sleep!\n");
    signal(SIGALRM,wakeUp);
    alarm(4);
    //将进程挂起
    pause();
    printf("good morning!\n");

    return EXIT_SUCCESS;
}
````
alarm(time);执行之后告诉内核，让内核在time秒时间之后向该进程发送一个定时信号，然后该进程捕获该信号并处理；  
pause()函数使该进程暂停让出CPU,但是该函数的暂停是可被中断的睡眠，也就是说收到了中断信号之后处理完毕，再重新执行该进程的时候就直接执行pause()函数之后的语句；注意的是一个进程只能有一个闹钟时间，如果调用alarm()之前已经设置了闹钟时间，那么任何以前的闹钟时间都会被新值所代替。  

综上所述，内核的sleep()函数是在挂起原语的基础上利用定时器实现的。

