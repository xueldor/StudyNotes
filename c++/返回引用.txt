代码： 
```c++
int ii = 9;
int& a() {
	cout<<&ii<<endl;
	return ii;
}

int main()
{
	int& aa = a();
	cout<<&aa<<endl;
}
``` 

输出：
```
00007FF67C499028
00007FF67C499028
请按任意键继续. . .
```

这里如果main函数里把&去掉：
int aa = a();
就会发生拷贝：
```
00007FF74D309028
00000000001EF9E4
请按任意键继续. . .
```

所以，当函数返回一个引用时，调用函数不加引用当然没问题，就像`int aa = a();`这样。但是这不过是把函数返回的对象赋给aa而已。 
如果函数返回不是引用，则理论上先把函数返回的对象赋给一个临时对象，再把临时对象赋给aa。 
返回引用，调用的外面也加引用，才能真正的一直引用一个对象，即`int& aa = a();`这样。 

假如函数返回不加引用&， 外面`int& aa = a();`会怎样呢？报错。不能引用一个右值，即不能引用一个没有名字的临时对象。必须加const： `const int& aa = a();`。新标准右值引用解决了这个问题。 

（以上理论是基于C++标准，实际中编译器经常会做一些优化，尤其越是新的编译器，越是优化多。C++标准中也是允许这种优化的）