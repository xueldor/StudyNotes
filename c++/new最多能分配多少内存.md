首先这个问题显然和平台、硬件资源有关。

就我当前机器试验如下。

硬件配置：

内存 真实是16G，但是hypervisor架构，QNX+Android，Android里面free或cat /proc/meminfo查看是10G，

64位。

环境 C++ int为4字节，std::size_t为8字节。

程序：不停new一段内存，释放，然后new更大内存。试探极限。

知识：

用top命令，输出包括VIRT、RES、SHR等字段。

- VIRT：表示进程当前所使用的虚拟内存大小，包括代码段、数据段、共享库、映射文件等占用的内存大小。

- RES：表示进程当前所使用的物理内存大小，即实际占用的内存大小，不包括共享库、映射文件等。
- SHR：表示进程当前所使用的共享内存大小，即多个进程共享的内存大小。

结果：

* 只new内存，不实际使用

  哪怕new一段非常大的内存（std::size_t的max值，2^64-1字节即2^34G,远远超出了物理内存），也不会报错。

  用top命令查看，VIRT内存和RES都不会增大。

* new一段内存，然后访问最后一个字节。

  到了分配大约382.36G的时候，抛std::bad_alloc异常。同时top命令看到进程的VIRT内存越来越大，到355G的时候，刚好程序抛异常。考虑top 3s更新一次，VIRT最大应该就是代码new的内存，即382G。

  所以虽然访问了最后一个字节，但是实际仍然不会分配整个数组的物理空间，但是会占用虚拟内存空间，达到上限会抛异常。

* new一段内存，然后用memset填充整段内存

  这似乎显然必须分配全部的物理内存。但实测诡异，依然没分配RES，说明现代计算机优化太好了。然后又添加一段代码，总之确保内存是真实分配的。top命令可以看到RES 在增大。

  申请内存到达8494M时，安卓界面发生重启，但是系统没重启。应该是触发了lowmemorykiller。之后界面重启频繁。系统变得非常卡顿。

  最后没等到std::bad_alloc异常，系统就重启了。大约是11G~12G的样子。

  

  试验说明，系统对单个native进程的申请内存没有限制，只要物理内存够，就会分配。

  在new操作前后加try-catch没有意义，因为Lazy Allocation机制，真实的分配发生在内存真正被使用到的时候，所以new按理是不会抛bad_alloc的。对于安卓系统，我实测下，哪怕真的内存不足了，也不会抛这个异常，安卓系统会直接重启。