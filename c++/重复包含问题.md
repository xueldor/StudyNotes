**一个**文件可能会重复include一个头文件，这是避免不了的，比如A.h包含了X.h, B.h也包含了X.h。因为A和B都要用到X里的东西，所以这两个include避不开。

然后假如C.h同时用到A和B，那么这种情况X.h就会在C.h中包含两次。

为了解决，有两种方法：

```c++
#pragma once
//或者
#ifndef XX_H
#define  XX_H
...
#endif
```

这个知识学过C++的一定都知道。但我这里想说的是，每个cpp文件都是单独编译成中间文件（ 俗称目标文件，linux上面一般后缀是.o，visual studio是.obj）,然后再把这些文件链接成可执行文件（或库）。而预处理发生在编译前，所以，这两种方法，只是保证同一个cpp包含两次“X.h”时，只有一份的“X.h”，而不同的cpp仍然各自有一份“X.h”。

即，A.cpp通过include “A.h”,包含了一份X.h, B.cpp通过包含B.h，也包含了一份X.h，他们编译成A.o和B.o时，A.o和B.o都有一份X的代码。

C.cpp因为包含了A.h和B.h，所以相当于include “C.h”了两次，通过“#pragma once”或“#ifndef”，在第二个include处，不把C.h的内容放进来。

所以导致的一个后果是, 即使所有头文件都加了“#pragma once”，在链接阶段，仍然可能会发生变量重复定义的异常，如：

```
1>a.obj : error LNK2005: "int a" (?a@@3HA) 已经在 test.obj 中定义
1>E:\MyCode\VSCppTest\TestCpp\x64\Debug\TestCpp.exe : fatal error LNK1169: 找到一个或多个多重定义的符号
```

这个异常是这样发生的：

```c++
A.h:
#ifndef AA
#define  AA
int a;
#endif

A.cpp:
#include "A.h"

test.cpp:
#include "A.h"

```

于是，A.obj里面定义了a变量，test.obj里面也定义了a变量，链接到exe里时就异常了。

解决这个问题，你可以把a定义为static的：

```c++
A.h:
static int a = 2;
```

因为static作用域在当前文件，因此，后果是，A.obj里的a变量和test.obj里的a变量是两个不同变量，彼此互不影响。特定情形下可以用这种写法，但是因为很容易一不小心就会误把两个a当做一个变量使用，比如在a.cpp里面赋值，在test.cpp里使用，从而代码出现错误，所以建议是头文件不要声明static变量。const因为是常量值不可能被改变，所以是共享一个对象，还是多个对象对代码逻辑没有区别，所以可以放头文件没问题。

更一般的，我们应该遵守原则。我们总是强调，头文件里只放声明，不要放定义。上面例子应该这样写：

```C++
A.h:
extern int a;//只声明

A.cpp:
int a = 2;//定义
```

这样就可以保证所有包含A.h的代码用的a都是A.cpp里的。

但是，这个规则有几个例外：

* 头文件中可以写const对象的定义，因为全局的const对象只在当前文件中有效。（类似前面a变量声明为static的方案）。

  既然是const，而且都是从一个头文件中包含进去的，那么所有的cpp文件中的这个const对象的值都是相同的，就好像大家都是用的同一个对象。

* 同理，static对象的定义也可以放进头文件，每个cpp文件中的这个static对象是独立的，互不干扰。

* 头文件中可 以写内联函数（inline）的定义。

  因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链 接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，我们只好把它放到cpp文件里，但是我们知道，编译是每个cpp文件先单独编译成obj文件，编译期间是看不到其它cpp文件里的定义的。所以在其他的文件中还使用到了这个内联函数那怎么办 呢？

  这几乎没什么太好的解决办法，因此C++规定，内联函数可以在程序中定义多次，只要内联函数在一个.cpp文件中只出现一次，并且在所有的.cpp文 件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。

* 头文件中可以写类（class）的定义

  因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的 定义的要求，跟内联函数是基本一样的。

* 类的成员函数的实现代码也可以直接写进头文件的类定义里面，因为编译器会视这个函数为 内联的。

  ```c++
  class B {
  public :
  	void funB(){//funB是内联函数
  	}
  };
  ```

  但是，我们还是建议把函数成员的实现代码放在.cpp文件。

* 类的数据成员，要等到具体的对象被创建时才会被定义（分配空间），所以类里面的数据成员只是声明，不算是定义。

**互相包含问题**

有时，A类引用了B类，B也应用了A。如果A.h里面include了B，那么B.h就不能出现include A（由于加了#pragma once或#ifndef，其实B里面include了A也没事，直接忽略这个包含语句）。

当cpp里的include语句都展开后，A类和B类在一个文件里，不管是怎么包含的，总有一个先后顺序，要么A类出现在前面，要么B类在前面，那么前面的类是不能引用后面的类的。

这里，要使用前置声明：

```c++
//声明
class A;

class B {
public :
	int id;
	void funB(A* a);
};
//include 语句展开后，A类定义在B的下面
class A{
    。。。
}
```

但是，声明只是一个纯粹声明，没有伴随其定义，因此，前置声明有如下限制：

（1）只能定义指向前置声明的类的指针或引用。

（2）以前置声明类型为函数的参数或返回值，该函数只能声明不能定义。

示例：

```c++
#ifndef AA
#define  AA

#include "B.h"
class B;

class A{
public :
	//wrong, 只能是 指针或引用
	//B bb;

	//right
	B* b1;
	//right
	B& b2;

	//成员变量b2是引用，要创建一个构造函数对b2初始化
	A(B* b):b2(*b){}

	//right
	B funA(B* b);
	//right
	B& fun1(B b);

	int dig;
};

#endif
```

`B bb`是错的，因为通过前置声明`class B`，A类只知道有B这个类，而这个类的布局、占用空间大小都是未知的，故，不能在A中出现B对象。

但是指针和引用是可以的，因为指针只是一个地址，大小是固定的；而引用类型道理也差不多，相当于个占位符号或别名，不会在A的内存布局里开辟B的空间。

`B funA(B* b);`是正确的。B作为函数的参数或返回值，不管是B，还是B*，还是B&，都是可以的，因为这里只是一个函数声明。试一下把funA的方法体也放在这里（内联方式），并且在方法体内用到B（比如调用B的某个函数），编译一定会报错，因为此时，只是通过声明知道有B这个类，不知道B内部有什么。

把funA的方法体放到A.cpp文件中，然后A.cpp 文件前面include 一下B.h，然后就可以在funA的方法体内愉快地使用B了，不会有任何问题。（往往不需要include B,因为A.cpp一定会include A.h,通过A.h就引入了B.h）。

综上，前置声明的限制还是蛮多的，而且还有许多其它缺陷（哪些自行百度）。不到不得已，不要用。



## 附录

一.

1. 普通的全局变量，作用域是整个程序

   ```c++
   //A.cpp
   int first;
   //B.cpp
   int first;
   
   1>正在链接...
   1>A.obj : error LNK2005: "int first" (?first@@3HA) 已经在 B.obj 中定义
   ```

2. const全局变量，作用域是这个cpp文件

   ```c++
   //A.cpp
   const int first = 1;
   //B.cpp
   const int first = 3;
   ```

   编译正常。由此推断，static const和const一个意思。

3. extern const全局变量，通过extern关键字，将这个全局变量的作用域声明为整个程序。

   ```c++
   //A.cpp
   extern const int first = 1;
   //B.cpp
   extern const int first = 3;
   
   1>正在链接...
   1>B.obj : error LNK2005: "int const first" (?first@@3HB) 已经在 A.obj 中定义
   1>E:\MyCode\VSCppTest\TestCpp\x64\Debug\TestCpp.exe : fatal error LNK1169: 找到一个或多个多重定义的符号
   ```
   
   可以认为普通的全局变量默认就是extern的，const默认就是static的。即，`int first=1；`等价`extern int first=1`。不过要注意的是，全局范围的`int first;`默认初始化为0，而``extern int first;`仅仅是一个声明，没有定义变量。

二.

类的成员变量是引用，这种很少见，作为一个冷僻的知识点，末尾额外说一下。因为引用类型必须在声明时即初始化：

```c++
//错	
int bb = 1;
int & test;
test = bb;

//对
int bb = 1;
int & test = bb;
```

当一个类，有某个成员变量是引用时，我们也要立即初始化，怎么做呢？因为要保证类创建时，就初始化了此引用变量，因此只能是在构造函数上做文章。

故，一旦类有某个成员变量是引用，就：

​	1）不会生成默认构造函数；

​	2）你要手动添加一个构造函数，并且通过初始化列表给引用变量赋值；

“通过初始化列表”这点，和const成员变量是一个道理。